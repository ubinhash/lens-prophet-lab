"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HardhatZksyncSigner = void 0;
const zksync_ethers_1 = require("zksync-ethers");
const utils_1 = require("zksync-ethers/build/utils");
const ethers_1 = require("ethers");
const utils_2 = require("../utils");
const rich_wallets_1 = require("../rich-wallets");
const constants_1 = require("../constants");
const hardhat_zksync_eip712_signer_1 = require("./hardhat-zksync-eip712-signer");
class HardhatZksyncSigner extends zksync_ethers_1.Signer {
    constructor(provider, address, accountWallet) {
        super(provider, address);
        this.providerL2 = provider;
        this.accountWallet = accountWallet;
    }
    static async create(hre, provider, address) {
        return new HardhatZksyncSigner(provider, address, await this._getProperSigner(hre, address));
    }
    async sendTransaction(transaction) {
        const address = await this.getAddress();
        const from = !transaction.from ? address : await ethers_1.ethers.resolveAddress(transaction.from);
        if (!(0, utils_1.isAddressEq)(from, address)) {
            throw new Error('Transaction `from` address mismatch!');
        }
        transaction.from = from;
        if (!this.accountWallet) {
            throw new Error(`Account ${from} is not managed by the node you are connected to.`);
        }
        if (this.accountWallet instanceof hardhat_zksync_eip712_signer_1.HardhatZksyncEIP712Signer) {
            return this._sendTransaction(transaction);
        }
        return this.accountWallet.sendTransaction(transaction);
    }
    async signMessage(message) {
        if (!this.accountWallet) {
            throw new Error(`Account ${await this.getAddress()} is not managed by the node you are connected to.`);
        }
        return this.accountWallet.signMessage(message);
    }
    async signTypedData(domain, types, value) {
        if (!this.accountWallet) {
            throw new Error(`Account ${await this.getAddress()} is not managed by the node you are connected to.`);
        }
        return this.accountWallet.signTypedData(domain, types, value);
    }
    async signTransaction(transaction) {
        if (!this.accountWallet) {
            throw new Error(`Account ${await this.getAddress()} is not managed by the node you are connected to.`);
        }
        const tx = await this._prepareTransaction(transaction);
        return this.accountWallet.signTransaction(tx);
    }
    async _prepareTransaction(transaction) {
        const tx = await this.populateFeeData(transaction);
        if (tx.type === null || tx.type === undefined || tx.type === utils_1.EIP712_TX_TYPE || tx.customData) {
            const address = await this.getAddress();
            tx.from ??= address;
            if (!(0, utils_1.isAddressEq)(await ethers_1.ethers.resolveAddress(tx.from), address)) {
                throw new Error('Transaction `from` address mismatch!');
            }
            const zkTx = {
                type: tx.type ?? utils_1.EIP712_TX_TYPE,
                value: tx.value ?? 0,
                data: tx.data ?? '0x',
                nonce: tx.nonce ?? (await this.getNonce()),
                maxFeePerGas: tx.gasPrice ?? tx.maxFeePerGas,
                maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
                gasLimit: tx.gasLimit,
                chainId: tx.chainId ?? (await this.provider.getNetwork()).chainId,
                to: await ethers_1.ethers.resolveAddress(tx.to),
                customData: this._fillCustomData(tx.customData ?? {}),
                from: address,
            };
            zkTx.customData ??= {};
            return zkTx;
        }
        return await super.populateTransaction(tx);
    }
    async populateFeeData(transaction) {
        const tx = (0, ethers_1.copyRequest)(transaction);
        if (tx.gasPrice && (tx.maxFeePerGas || tx.maxPriorityFeePerGas)) {
            throw new Error('Provide combination of maxFeePerGas and maxPriorityFeePerGas or provide gasPrice. Not both!');
        }
        if (!this.providerL2) {
            throw new Error('Initialize provider L2');
        }
        if (!tx.gasLimit || (!tx.gasPrice && (!tx.maxFeePerGas || !tx.maxPriorityFeePerGas))) {
            const fee = await this.providerL2.estimateFee(tx);
            tx.gasLimit ??= fee.gasLimit;
            if (!tx.gasPrice && tx.type === 0) {
                tx.gasPrice = fee.maxFeePerGas;
            }
            else if (!tx.gasPrice && tx.type !== 0) {
                tx.maxFeePerGas ??= fee.maxFeePerGas;
                tx.maxPriorityFeePerGas ??= fee.maxPriorityFeePerGas;
            }
        }
        return tx;
    }
    async _sendTransaction(transaction) {
        if (transaction.type === null ||
            transaction.type === undefined ||
            transaction.type === utils_1.EIP712_TX_TYPE ||
            transaction.customData) {
            const zkTx = await this._prepareTransaction(transaction);
            zkTx.customData = zkTx.customData ?? {};
            zkTx.customData.customSignature = await this.accountWallet.signTransaction(zkTx);
            const txBytes = (0, utils_1.serializeEip712)(zkTx);
            return await this.provider.broadcastTransaction(txBytes);
        }
        return (await super.sendTransaction(transaction));
    }
    static async _getProperSigner(hre, address) {
        let signer = await (0, utils_2.findWalletFromAddress)(hre, address);
        if (!signer && (await (0, utils_2.isImpersonatedSigner)(hre.ethers.provider, address))) {
            signer = new hardhat_zksync_eip712_signer_1.HardhatZksyncEIP712Signer(new zksync_ethers_1.Wallet(rich_wallets_1.richWallets[constants_1.LOCAL_CHAIN_IDS_ENUM.ERA_NODE][0].privateKey, hre.ethers.provider, hre.ethers.providerL1), hre.ethers.provider.getNetwork().then((n) => Number(n.chainId)));
        }
        return signer;
    }
}
exports.HardhatZksyncSigner = HardhatZksyncSigner;
//# sourceMappingURL=hardhat-zksync-signer.js.map