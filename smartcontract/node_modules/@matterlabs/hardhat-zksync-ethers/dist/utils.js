"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isImpersonatedSigner = exports.isValidEthNetworkURL = exports.isHttpNetworkConfig = exports.getSignerOrWallet = exports.getRichWalletsIfPossible = exports.getSignerAccounts = exports.findWalletFromAddress = exports.createProviders = exports.isArtifact = exports.isFactoryOptions = exports.getWalletsFromAccount = exports.isNumber = exports.isString = exports.isHardhatNetworkAccountsConfigStrings = exports.isHardhatNetworkHDAccountsConfig = void 0;
const zksync_ethers_1 = require("zksync-ethers");
const ethers_1 = require("ethers");
const utils_1 = require("zksync-ethers/build/utils");
const constants_1 = require("./constants");
const rich_wallets_1 = require("./rich-wallets");
const errors_1 = require("./errors");
const hardhat_zksync_provider_1 = require("./hardhat-zksync-provider");
const helpers_1 = require("./helpers");
function isHardhatNetworkHDAccountsConfig(object) {
    return 'mnemonic' in object;
}
exports.isHardhatNetworkHDAccountsConfig = isHardhatNetworkHDAccountsConfig;
function isHardhatNetworkAccountsConfigStrings(object) {
    return typeof object[0] === 'string';
}
exports.isHardhatNetworkAccountsConfigStrings = isHardhatNetworkAccountsConfigStrings;
function isString(object) {
    return typeof object === 'string';
}
exports.isString = isString;
function isNumber(object) {
    return typeof object === 'number';
}
exports.isNumber = isNumber;
async function getWalletsFromAccount(hre, accounts) {
    if (!accounts || accounts === 'remote') {
        return await getRichWalletsIfPossible(hre);
    }
    if (isHardhatNetworkAccountsConfigStrings(accounts)) {
        const accountPrivateKeys = accounts;
        const wallets = accountPrivateKeys.map((accountPrivateKey) => new zksync_ethers_1.Wallet(accountPrivateKey, hre.ethers.provider).connectToL1(hre.ethers.providerL1));
        return wallets;
    }
    if (isHardhatNetworkHDAccountsConfig(accounts)) {
        const account = accounts;
        const wallet = zksync_ethers_1.Wallet.fromMnemonic(account.mnemonic)
            .connect(hre.ethers.provider)
            .connectToL1(hre.ethers.providerL1);
        return [wallet];
    }
    return [];
}
exports.getWalletsFromAccount = getWalletsFromAccount;
function isFactoryOptions(walletOrOptions) {
    if (walletOrOptions === undefined || 'provider' in walletOrOptions) {
        return false;
    }
    return true;
}
exports.isFactoryOptions = isFactoryOptions;
function isArtifact(artifact) {
    const { contractName, sourceName, abi, bytecode, deployedBytecode, linkReferences, deployedLinkReferences, factoryDeps, } = artifact;
    return (typeof contractName === 'string' &&
        typeof sourceName === 'string' &&
        Array.isArray(abi) &&
        typeof bytecode === 'string' &&
        typeof deployedBytecode === 'string' &&
        linkReferences !== undefined &&
        deployedLinkReferences !== undefined &&
        factoryDeps !== undefined);
}
exports.isArtifact = isArtifact;
function createProviders(hre) {
    const network = hre.network;
    const networks = hre.config.networks;
    const networkName = network.name;
    if (!network.zksync) {
        throw new errors_1.ZkSyncEthersPluginError(`Only deploying to ZKsync network is supported.\nNetwork '${networkName}' in 'hardhat.config' needs to have 'zksync' flag set to 'true'.`);
    }
    if (networkName === 'hardhat') {
        return {
            ethWeb3Provider: _createDefaultEthProvider(),
            zkWeb3Provider: _createDefaultZkProvider(hre),
        };
    }
    const networkConfig = network.config;
    if (!isHttpNetworkConfig(networkConfig)) {
        throw new errors_1.ZkSyncEthersPluginError(`Only deploying to ZKsync network is supported.\nNetwork '${networkName}' in 'hardhat.config' needs to have 'url' specified.`);
    }
    if (networkConfig.ethNetwork === undefined) {
        throw new errors_1.ZkSyncEthersPluginError(`Only deploying to ZKsync network is supported.\nNetwork '${networkName}' in 'hardhat.config' needs to have 'ethNetwork' (layer 1) specified.`);
    }
    let ethWeb3Provider;
    const ethNetwork = networkConfig.ethNetwork;
    if (constants_1.SUPPORTED_L1_TESTNETS.includes(ethNetwork)) {
        ethWeb3Provider =
            ethNetwork in networks && isHttpNetworkConfig(networks[ethNetwork])
                ? new ethers_1.ethers.JsonRpcProvider(networks[ethNetwork].url)
                : ethers_1.ethers.getDefaultProvider(ethNetwork);
    }
    else {
        if (ethNetwork === 'localhost' || ethNetwork === '') {
            ethWeb3Provider = _createDefaultEthProvider();
        }
        else if (isValidEthNetworkURL(ethNetwork)) {
            ethWeb3Provider = new ethers_1.ethers.JsonRpcProvider(ethNetwork);
        }
        else {
            ethWeb3Provider =
                ethNetwork in networks && isHttpNetworkConfig(networks[ethNetwork])
                    ? new ethers_1.ethers.JsonRpcProvider(networks[ethNetwork].url)
                    : ethers_1.ethers.getDefaultProvider(ethNetwork);
        }
    }
    const zkWeb3Provider = new hardhat_zksync_provider_1.HardhatZksyncEthersProvider(hre, network.config.url);
    return { ethWeb3Provider, zkWeb3Provider };
}
exports.createProviders = createProviders;
async function findWalletFromAddress(hre, address, wallets) {
    if (!wallets) {
        wallets = await (0, helpers_1.getWallets)(hre);
    }
    return wallets.find((w) => (0, utils_1.isAddressEq)(w.address, address));
}
exports.findWalletFromAddress = findWalletFromAddress;
async function getSignerAccounts(hre) {
    const accounts = await hre.ethers.provider.send('eth_accounts', []);
    if (!accounts || accounts.length === 0) {
        const wallets = await (0, helpers_1.getWallets)(hre);
        return wallets.map((w) => w.address);
    }
    const allWallets = await (0, helpers_1.getWallets)(hre);
    return accounts.filter((account) => allWallets.some((wallet) => (0, utils_1.isAddressEq)(wallet.address, account)));
}
exports.getSignerAccounts = getSignerAccounts;
async function getRichWalletsIfPossible(hre) {
    const chainId = await hre.ethers.providerL2.send('eth_chainId', []);
    if (constants_1.LOCAL_CHAIN_IDS.includes(chainId)) {
        const chainIdEnum = chainId;
        return rich_wallets_1.richWallets[chainIdEnum].map((wallet) => new zksync_ethers_1.Wallet(wallet.privateKey, hre.ethers.provider).connectToL1(hre.ethers.providerL1));
    }
    return [];
}
exports.getRichWalletsIfPossible = getRichWalletsIfPossible;
function _createDefaultEthProvider() {
    return new ethers_1.ethers.JsonRpcProvider(constants_1.ETH_DEFAULT_NETWORK_RPC_URL);
}
function _createDefaultZkProvider(hre) {
    return new hardhat_zksync_provider_1.HardhatZksyncEthersProvider(hre);
}
function getSignerOrWallet(signerWalletOrFactoryOptions) {
    if (signerWalletOrFactoryOptions === undefined) {
        return undefined;
    }
    if (isFactoryOptions(signerWalletOrFactoryOptions)) {
        if (signerWalletOrFactoryOptions.wallet) {
            return signerWalletOrFactoryOptions.wallet;
        }
        else if (signerWalletOrFactoryOptions.signer) {
            return signerWalletOrFactoryOptions.signer;
        }
        return undefined;
    }
    return signerWalletOrFactoryOptions;
}
exports.getSignerOrWallet = getSignerOrWallet;
function isHttpNetworkConfig(networkConfig) {
    return 'url' in networkConfig;
}
exports.isHttpNetworkConfig = isHttpNetworkConfig;
function isValidEthNetworkURL(string) {
    try {
        new URL(string);
        return true;
    }
    catch (_) {
        return false;
    }
}
exports.isValidEthNetworkURL = isValidEthNetworkURL;
async function isImpersonatedSigner(provider, address) {
    const chainId = await provider.send('eth_chainId', []);
    if (!constants_1.LOCAL_CHAINS_WITH_IMPERSONATION.includes(chainId)) {
        return false;
    }
    const result = await provider.send('hardhat_stopImpersonatingAccount', [address]);
    if (!result) {
        return false;
    }
    await provider.send('hardhat_impersonateAccount', [address]);
    return true;
}
exports.isImpersonatedSigner = isImpersonatedSigner;
//# sourceMappingURL=utils.js.map