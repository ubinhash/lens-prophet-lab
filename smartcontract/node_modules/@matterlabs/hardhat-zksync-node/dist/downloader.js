"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCServerDownloader = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const utils_1 = require("./utils");
const errors_1 = require("./errors");
const constants_1 = require("./constants");
class RPCServerDownloader {
    constructor(binaryDir, initialTag) {
        this._tagRegex = /^\d+\.\d+\.(\d+)(-[A-Za-z0-9.]+)?$|^\d+\.\d+\.\*(?!-)[A-Za-z0-9.]*$/;
        this._tagsInfoFile = constants_1.DEFAULT_RELEASE_CACHE_FILE_NAME;
        this._binaryDir = binaryDir;
        if (!this._tagRegex.test(initialTag) && initialTag !== 'latest') {
            throw new errors_1.ZkSyncNodePluginError(`Invalid tag format: ${initialTag}`);
        }
        this._initialTag = initialTag;
        this._tagsInfoFilePath = path_1.default.join(this._binaryDir, this._tagsInfoFile);
    }
    async downloadIfNeeded(force, binaryPath) {
        if (binaryPath) {
            this.binaryPath = binaryPath;
            return;
        }
        if (!(await this._isTagsInfoValid()) || force) {
            await this._downloadTagInfo();
        }
        const tagsInfo = await this._getTagsInfo();
        this._tag = (0, utils_1.resolveTag)(tagsInfo.tags, tagsInfo.latest, this._initialTag);
        if (force) {
            await this._download(this._tag);
            return;
        }
        if (await this._isBinaryPathExists(this._tag)) {
            await this._postProcessDownload(this._tag);
            return;
        }
        await this._download(this._tag);
    }
    async _download(tag) {
        const url = await (0, utils_1.getNodeUrl)(constants_1.ZKNODE_BIN_REPOSITORY, tag);
        try {
            console.info(chalk_1.default.yellow(`Downloading anvil-zksync binary, release: ${tag}`));
            await (0, utils_1.download)(url, await this._createBinaryPath(tag), constants_1.PLUGIN_NAME, tag, 30000);
            await this._postProcessDownload(tag);
            console.info(chalk_1.default.green('anvil-zksync binary downloaded successfully'));
        }
        catch (error) {
            throw new errors_1.ZkSyncNodePluginError(`Error downloading binary from URL ${url}: ${error.message}`);
        }
    }
    async _isBinaryPathExists(tag) {
        return fs_extra_1.default.existsSync(await this.getBinaryPath(tag));
    }
    async getBinaryPath(tag) {
        if (this.binaryPath) {
            return this.binaryPath;
        }
        if (!tag && !this._tag) {
            throw new errors_1.ZkSyncNodePluginError('Tag is not set');
        }
        return path_1.default.join(this._binaryDir, tag || this._tag);
    }
    async _createBinaryPath(version) {
        return path_1.default.join(this._binaryDir, version);
    }
    async _postProcessDownload(tag) {
        const binaryPath = await this.getBinaryPath(tag);
        fs_extra_1.default.chmodSync(binaryPath, 0o755);
    }
    async _isTagsInfoValid() {
        if (!(await this._isTagsInfoExists())) {
            return false;
        }
        const stats = await fs_extra_1.default.stat(this._tagsInfoFilePath);
        const age = new Date().valueOf() - stats.ctimeMs;
        return age < constants_1.DEFAULT_RELEASE_VERSION_INFO_CACHE_PERIOD;
    }
    async _isTagsInfoExists() {
        return fs_extra_1.default.existsSync(this._tagsInfoFilePath);
    }
    async _getTagsInfo() {
        if (!(await this._isTagsInfoValid())) {
            return undefined;
        }
        return await fs_extra_1.default.readJSON(this._tagsInfoFilePath);
    }
    async _downloadTagInfo() {
        const allTags = await (0, utils_1.getAllTags)(constants_1.ZKNODE_BIN_OWNER, constants_1.ZKNODE_BIN_REPOSITORY_NAME, constants_1.USER_AGENT, constants_1.DEFAULT_TIMEOUT_MILISECONDS);
        const latestTag = await (0, utils_1.getLatestRelease)(constants_1.ZKNODE_BIN_OWNER, constants_1.ZKNODE_BIN_REPOSITORY_NAME, constants_1.USER_AGENT, constants_1.DEFAULT_TIMEOUT_MILISECONDS);
        await (0, utils_1.ensureDirectory)(this._tagsInfoFilePath, { mode: 0o755 });
        await fs_extra_1.default.writeJSON(this._tagsInfoFilePath, { tags: allTags, latest: latestTag });
    }
}
exports.RPCServerDownloader = RPCServerDownloader;
//# sourceMappingURL=downloader.js.map