"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const config_1 = require("hardhat/config");
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const plugins_1 = require("hardhat/plugins");
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const constants_1 = require("./constants");
const server_1 = require("./server");
const utils_1 = require("./utils");
const downloader_1 = require("./downloader");
const errors_1 = require("./errors");
const global_interceptor_1 = require("./core/global-interceptor");
const script_runner_1 = require("./core/script-runner");
require("./type-extensions");
require("@matterlabs/hardhat-zksync-telemetry");
(0, config_1.extendConfig)((config, userConfig) => {
    config.zksyncAnvil = {
        version: userConfig.zksyncAnvil?.version || constants_1.DEFAULT_ZKSYNC_ANVIL_VERSION,
        binaryPath: userConfig.zksyncAnvil?.binaryPath || undefined,
    };
});
(0, config_1.task)(task_names_1.TASK_RUN).setAction(async (args, hre, runSuper) => {
    if (!hre.network.zksync || hre.network.name !== plugins_1.HARDHAT_NETWORK_NAME) {
        await runSuper(args, hre);
        return;
    }
    await (0, script_runner_1.runScriptWithHardhat)(hre.hardhatArguments, hre.config.zksyncAnvil, path_1.default.resolve(args.script));
});
// Subtask to download the binary
(0, config_1.subtask)(constants_1.TASK_NODE_ZKSYNC_DOWNLOAD_BINARY, 'Downloads the JSON-RPC server binary')
    .addFlag('force', 'Force download even if the binary already exists')
    .addOptionalParam('tag', 'Specified node release for use', undefined)
    .setAction(async ({ force, tag, }, _hre) => {
    // Directory where the binaries are stored
    const rpcServerBinaryDir = await (0, utils_1.getRPCServerBinariesDir)();
    const version = tag || _hre.config.zksyncAnvil.version;
    // Get the latest release of the binary
    const downloader = new downloader_1.RPCServerDownloader(rpcServerBinaryDir, version);
    if (_hre.config.zksyncAnvil.binaryPath) {
        console.warn(chalk_1.default.yellow('Binary path will have priority over the download of the binary file from the tag version'));
    }
    // Download binary if needed
    await downloader.downloadIfNeeded(force, _hre.config.zksyncAnvil.binaryPath);
    return await downloader.getBinaryPath();
});
// Subtask to create the server
(0, config_1.subtask)(constants_1.TASK_NODE_ZKSYNC_CREATE_SERVER, 'Creates a JSON-RPC server for ZKsync node')
    .addParam('binaryPath', 'Path to the binary file', undefined, config_1.types.string)
    .setAction(async ({ binaryPath, }, _hre) => {
    // Create the server
    const server = new server_1.JsonRpcServer(binaryPath);
    return server;
});
(0, config_1.task)(task_names_1.TASK_NODE, 'Start a ZKSync Node')
    // Network Options
    .addOptionalParam('chainId', 'Chain ID to use - default: 260', undefined, config_1.types.int)
    // Logging Options
    .addOptionalParam('log', 'Log filter level (error, warn, info, debug) - default: info', undefined, config_1.types.string)
    .addOptionalParam('logFilePath', 'Path to the file where logs should be written - default: `anvil-zksync.log`', undefined, config_1.types.string)
    .addFlag('silent', 'Disables logs')
    // Options
    .addOptionalParam('timestamp', 'Override genesis timestamp', undefined, config_1.types.bigint)
    .addOptionalParam('init', ' Initialize the genesis block with the given `genesis.json` file', undefined, config_1.types.string)
    .addOptionalParam('state', 'Load + dump snapshot on exit', undefined, config_1.types.string)
    .addOptionalParam('stateInterval', 'Interval to dump state', undefined, config_1.types.bigint)
    .addFlag('preserveHistoricalStates', 'Preserve historical states')
    .addOptionalParam('order', 'Transaction ordering in the mempool - default: fifo', undefined, config_1.types.string)
    .addFlag('noMining', 'Mine blocks only when RPC clients call evm_mine')
    .addFlag('anvilZksyncVersion', 'Print version and exit')
    .addFlag('anvilZksyncHelp', 'Print help and exit')
    // General Options
    .addFlag('offline', 'Run in offline mode')
    .addFlag('healthCheckEndpoint', 'Enable health check endpoint')
    .addOptionalParam('configOut', 'Writes output of `anvil-zksync` as json to user-specified file', undefined, config_1.types.string)
    // L1 Options
    .addOptionalParam('spawnL1', 'Launch an Anvil L1 node on a specified port', undefined, config_1.types.int)
    .addOptionalParam('externalL1', 'Use an external L1 node', undefined, config_1.types.string)
    .addFlag('noRequestSizeLimit', 'Disable request size limit')
    .addFlag('autoExecuteL1', 'Auto-execute L1 batches after L2 sealing')
    // Block Options
    .addOptionalParam('blockTime', 'Seal blocks at a fixed interval', undefined, config_1.types.bigint)
    // Accounts Options
    .addOptionalParam('accounts', 'Pre-funded dev accounts', undefined, config_1.types.bigint)
    .addOptionalParam('balance', 'Pre-funded dev accounts balance', undefined, config_1.types.bigint)
    .addFlag('autoImpersonate', 'Auto-impersonate accounts')
    // Cache Options
    .addOptionalParam('cache', 'Cache type (none, disk, memory) - default: disk', undefined, config_1.types.string)
    .addOptionalParam('cacheDir', 'Cache directory location for `disk` cache - default: `.cache`', undefined, config_1.types.string)
    .addFlag('resetCache', 'Reset the local `disk` cache')
    // Debugging Options
    .addOptionalParam('verbosity', 'Verbosity level traces (vv, vvv)', undefined, config_1.types.string)
    .addFlag('showNodeConfig', 'Show node configuration')
    .addOptionalParam('showStorageLogs', 'Show storage log information (none, read, write, all) - default: none', undefined, config_1.types.string)
    .addOptionalParam('showVmDetails', 'Show VM details information (none, all) - default: none', undefined, config_1.types.string)
    .addOptionalParam('showGasDetails', 'Show Gas details information (none, all) - default: none', undefined, config_1.types.string)
    // Gas configuration
    .addOptionalParam('l1GasPrice', 'L1 gas price', undefined, config_1.types.bigint)
    .addOptionalParam('l2GasPrice', 'L2 gas price', undefined, config_1.types.bigint)
    .addOptionalParam('l1PubDataPrice', 'L1 pub data price', undefined, config_1.types.bigint)
    .addOptionalParam('priceScaleFactor', 'Gas price estimation scale factor', undefined, config_1.types.bigint)
    .addOptionalParam('limitScaleFactor', 'Gas limit estimation scale factor', undefined, config_1.types.bigint)
    // System Configuration
    .addOptionalParam('overrideBytecodesDir', 'Override the bytecodes directory', undefined, config_1.types.string)
    .addOptionalParam('devSystemContracts', 'Option for system contracts (built-in, local, built-in-without-security) default: built-in', undefined, config_1.types.string)
    .addFlag('enforceBytecodeCompression', 'Enforce bytecode compression')
    .addOptionalParam('systemContractsPath', 'Path to the system contracts', undefined, config_1.types.string)
    .addOptionalParam('protocolVersion', 'Protocol version to use for new blocks (default: 26)', undefined, config_1.types.int)
    .addFlag('emulateEvm', 'Emulate EVM')
    // Logging Options
    .addFlag('quite', 'Disables logs')
    // Server Options
    .addFlag('noCors', 'Disable CORS')
    .addOptionalParam('allowOrigin', 'Allow origin', undefined, config_1.types.string)
    // Custom base token configuration
    .addOptionalParam('baseTokenSymbol', 'Custom base token symbol', undefined, config_1.types.string)
    .addOptionalParam('baseTokenRatio', 'Custom base token ratio', undefined, config_1.types.string)
    // Plugin specific configuration
    .addFlag('force', 'Force download even if the binary already exists')
    .addOptionalParam('tag', 'Specified node release for use', undefined)
    .setAction(async (args, { network, run }, runSuper) => {
    if (network.zksync !== true || network.name !== plugins_1.HARDHAT_NETWORK_NAME) {
        return await runSuper();
    }
    await run(constants_1.TASK_NODE_ZKSYNC, args);
});
// Main task of the plugin. It starts the server and listens for requests.
(0, config_1.task)(constants_1.TASK_NODE_ZKSYNC, 'Starts a JSON-RPC server for ZKsync node')
    // Network Options
    .addOptionalParam('port', 'Port to listen on - default: 8011', undefined, config_1.types.int)
    .addOptionalParam('host', 'Host to listen on - default: 0.0.0.0', undefined, config_1.types.string)
    .addOptionalParam('chainId', 'Chain ID to use - default: 260', undefined, config_1.types.int)
    // Options
    .addOptionalParam('timestamp', 'Override genesis timestamp', undefined, config_1.types.bigint)
    .addOptionalParam('init', ' Initialize the genesis block with the given `genesis.json` file', undefined, config_1.types.string)
    .addOptionalParam('state', 'Load + dump snapshot on exit', undefined, config_1.types.string)
    .addOptionalParam('stateInterval', 'Interval to dump state', undefined, config_1.types.bigint)
    .addFlag('preserveHistoricalStates', 'Preserve historical states')
    .addOptionalParam('order', 'Transaction ordering in the mempool - default: fifo', undefined, config_1.types.string)
    .addFlag('noMining', 'Mine blocks only when RPC clients call evm_mine')
    .addFlag('anvilZksyncVersion', 'Print version and exit')
    .addFlag('anvilZksyncHelp', 'Print help and exit')
    // General Options
    .addFlag('offline', 'Run in offline mode')
    .addFlag('healthCheckEndpoint', 'Enable health check endpoint')
    .addOptionalParam('configOut', 'Writes output of `anvil-zksync` as json to user-specified file', undefined, config_1.types.string)
    // L1 Options
    .addOptionalParam('spawnL1', 'Launch an Anvil L1 node on a specified port', undefined, config_1.types.int)
    .addOptionalParam('externalL1', 'Use an external L1 node', undefined, config_1.types.string)
    .addFlag('noRequestSizeLimit', 'Disable request size limit')
    .addFlag('autoExecuteL1', 'Auto-execute L1 batches after L2 sealing')
    // Block Options
    .addOptionalParam('blockTime', 'Seal blocks at a fixed interval', undefined, config_1.types.bigint)
    // Accounts Options
    .addOptionalParam('accounts', 'Pre-funded dev accounts', undefined, config_1.types.bigint)
    .addOptionalParam('balance', 'Pre-funded dev accounts balance', undefined, config_1.types.bigint)
    .addFlag('autoImpersonate', 'Auto-impersonate accounts')
    // Cache Options
    .addOptionalParam('cache', 'Cache type (none, disk, memory) - default: disk', undefined, config_1.types.string)
    .addOptionalParam('cacheDir', 'Cache directory location for `disk` cache - default: `.cache`', undefined, config_1.types.string)
    .addFlag('resetCache', 'Reset the local `disk` cache')
    // Debugging Options
    .addOptionalParam('verbosity', 'Verbosity level traces (vv, vvv)', undefined, config_1.types.string)
    .addFlag('showNodeConfig', 'Show node configuration')
    .addOptionalParam('showStorageLogs', 'Show storage log information (none, read, write, all) - default: none', undefined, config_1.types.string)
    .addOptionalParam('showVmDetails', 'Show VM details information (none, all) - default: none', undefined, config_1.types.string)
    .addOptionalParam('showGasDetails', 'Show Gas details information (none, all) - default: none', undefined, config_1.types.string)
    // Gas configuration
    .addOptionalParam('l1GasPrice', 'L1 gas price', undefined, config_1.types.bigint)
    .addOptionalParam('l2GasPrice', 'L2 gas price', undefined, config_1.types.bigint)
    .addOptionalParam('l1PubdataPrice', 'L1 pub data price', undefined, config_1.types.bigint)
    .addOptionalParam('priceScaleFactor', 'Gas price estimation scale factor', undefined, config_1.types.bigint)
    .addOptionalParam('limitScaleFactor', 'Gas limit estimation scale factor', undefined, config_1.types.bigint)
    // System Configuration
    .addOptionalParam('overrideBytecodesDir', 'Override the bytecodes directory', undefined, config_1.types.string)
    .addOptionalParam('devSystemContracts', 'Option for system contracts (built-in, local, built-in-without-security) default: built-in', undefined, config_1.types.string)
    .addFlag('enforceBytecodeCompression', 'Enforce bytecode compression')
    .addOptionalParam('systemContractsPath', 'Path to the system contracts', undefined, config_1.types.string)
    .addOptionalParam('protocolVersion', 'Protocol version to use for new blocks (default: 26)', undefined, config_1.types.int)
    .addFlag('emulateEvm', 'Emulate EVM')
    // Fork Configuration
    .addOptionalParam('fork', 'Starts a local network that is a fork of another network (testnet, mainnet, http://XXX:YY)', undefined, config_1.types.string)
    .addOptionalParam('forkBlockNumber', 'Fork at the specified block height', undefined, config_1.types.int)
    .addOptionalParam('replayTx', 'Transaction hash to replay', undefined, config_1.types.string)
    // Logging Options
    .addFlag('quite', 'Disables logs')
    .addOptionalParam('log', 'Log filter level (trace, debug, info, warn, error, none) - default: info', undefined, config_1.types.string)
    .addOptionalParam('logFilePath', 'Path to the file where logs should be written - default: `anvil-zksync.log`', undefined, config_1.types.string)
    .addFlag('silent', 'Disables logs')
    // Server Options
    .addFlag('noCors', 'Disable CORS')
    .addOptionalParam('allowOrigin', 'Allow origin', undefined, config_1.types.string)
    // Custom base token configuration
    .addOptionalParam('baseTokenSymbol', 'Custom base token symbol', undefined, config_1.types.string)
    .addOptionalParam('baseTokenRatio', 'Custom base token ratio', undefined, config_1.types.string)
    // Plugin specific configuration
    .addOptionalParam('tag', 'Specified node release for use', undefined)
    .addFlag('force', 'Force download even if the binary already exists')
    .setAction(async ({ port, host, chainId, log, logFilePath, timestamp, init, state, stateInterval, preserveHistoricalStates, order, noMining, anvilZksyncVersion, anvilZksyncHelp, offline, healthCheckEndpoint, configOut, spawnL1, externalL1, noRequestSizeLimit, autoExecuteL1, blockTime, accounts, balance, autoImpersonate, l1GasPrice, l2GasPrice, l1PubdataPrice, baseTokenSymbol, baseTokenRatio, priceScaleFactor, limitScaleFactor, allowOrigin, noCors, cache, cacheDir, resetCache, verbosity, showNodeConfig, showStorageLogs, showVmDetails, showGasDetails, devSystemContracts, enforceBytecodeCompression, systemContractsPath, protocolVersion, emulateEvm, fork, forkBlockNumber, replayTx, tag, quiet, force, }, { run }) => {
    const commandArgs = (0, utils_1.constructCommandArgs)({
        port,
        host,
        chainId,
        log,
        logFilePath,
        timestamp,
        init,
        state,
        stateInterval,
        preserveHistoricalStates,
        order,
        noMining,
        anvilZksyncVersion,
        anvilZksyncHelp,
        offline,
        healthCheckEndpoint,
        configOut,
        spawnL1,
        externalL1,
        noRequestSizeLimit,
        autoExecuteL1,
        blockTime,
        accounts,
        balance,
        autoImpersonate,
        l1GasPrice,
        l2GasPrice,
        l1PubdataPrice,
        priceScaleFactor,
        limitScaleFactor,
        baseTokenSymbol,
        baseTokenRatio,
        allowOrigin,
        noCors,
        cache,
        cacheDir,
        resetCache,
        verbosity,
        showNodeConfig,
        showStorageLogs,
        showVmDetails,
        showGasDetails,
        devSystemContracts,
        enforceBytecodeCompression,
        systemContractsPath,
        protocolVersion,
        emulateEvm,
        fork,
        forkBlockNumber,
        replayTx,
        quiet,
        force,
        tag,
    });
    const binaryPath = await run(constants_1.TASK_NODE_ZKSYNC_DOWNLOAD_BINARY, { force, tag });
    // Create the server
    const server = await run(constants_1.TASK_NODE_ZKSYNC_CREATE_SERVER, { binaryPath });
    try {
        await server.listen(commandArgs);
    }
    catch (error) {
        throw new errors_1.ZkSyncNodePluginError(`Failed when running node: ${error.message}`);
    }
});
(0, config_1.subtask)(constants_1.TASK_RUN_NODE_ZKSYNC_IN_SEPARATE_PROCESS, 'Runs a Hardhat node-zksync task in a separate process.')
    .addVariadicPositionalParam('taskArgs', 'Arguments for the Hardhat node-zksync task.')
    .setAction(async ({ taskArgs = [] }, _hre) => {
    const currentPort = await (0, utils_1.getAvailablePort)(constants_1.START_PORT, constants_1.MAX_PORT_ATTEMPTS);
    const adjustedArgs = (0, utils_1.adjustTaskArgsForPort)(taskArgs, currentPort);
    const taskProcess = (0, child_process_1.spawn)('npx', ['hardhat', constants_1.TASK_NODE_ZKSYNC, ...adjustedArgs], {
        detached: true, // This creates a separate process group
        // stdio: 'inherit',
    });
    return {
        process: taskProcess,
        port: currentPort,
    };
});
(0, config_1.task)(task_names_1.TASK_TEST, async ({ testFiles, noCompile, parallel, bail, grep, }, { run, network, config }, runSuper) => {
    if (network.zksync !== true || network.name !== plugins_1.HARDHAT_NETWORK_NAME) {
        return await runSuper();
    }
    const platform = (0, utils_1.getPlatform)();
    if (platform === 'windows' || platform === '') {
        throw new errors_1.ZkSyncNodePluginError(`Unsupported platform: ${platform}`);
    }
    if (!noCompile) {
        await run(task_names_1.TASK_COMPILE, { quiet: true });
    }
    const files = await run(task_names_1.TASK_TEST_GET_TEST_FILES, { testFiles });
    const binaryPath = await run(constants_1.TASK_NODE_ZKSYNC_DOWNLOAD_BINARY, { force: false });
    const currentPort = await (0, utils_1.getAvailablePort)(constants_1.START_PORT, constants_1.MAX_PORT_ATTEMPTS);
    const commandArgs = (0, utils_1.constructCommandArgs)({ port: currentPort, quiet: true });
    const server = new server_1.JsonRpcServer(binaryPath);
    try {
        await server.listen(commandArgs, false);
        await (0, utils_1.waitForNodeToBeReady)(currentPort);
        await (0, utils_1.configureNetwork)(config, network, currentPort);
        let testFailures = 0;
        try {
            // Run the tests
            testFailures = await run(task_names_1.TASK_TEST_RUN_MOCHA_TESTS, {
                testFiles: files,
                parallel,
                bail,
                grep,
            });
        }
        finally {
            await server.stop();
        }
        process.exitCode = testFailures;
        return testFailures;
    }
    catch (error) {
        throw new errors_1.ZkSyncNodePluginError(`Failed when running node: ${error.message}`);
    }
});
(0, global_interceptor_1.interceptAndWrapTasksWithNode)();
//# sourceMappingURL=index.js.map