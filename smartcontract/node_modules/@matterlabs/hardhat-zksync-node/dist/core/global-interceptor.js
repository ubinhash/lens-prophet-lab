"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.interceptAndWrapTasksWithNode = void 0;
const plugins_1 = require("hardhat/plugins");
const utils_1 = require("../utils");
function interceptAndWrapTasksWithNode() {
    const zkSyncGlobal = global;
    const taskMap = zkSyncGlobal.__hardhatContext.tasksDSL.getTaskDefinitions();
    if (!zkSyncGlobal._zkSyncTasksForWrapping) {
        return;
    }
    zkSyncGlobal._zkSyncTasksForWrapping.taskNames.forEach((taskName) => {
        const foundTask = taskMap[taskName];
        if (!foundTask) {
            return;
        }
        if (foundTask.isSubtask) {
            zkSyncGlobal.__hardhatContext.tasksDSL.subtask(foundTask.name, foundTask.description, wrapTaskWithNode);
        }
        zkSyncGlobal.__hardhatContext.tasksDSL.task(foundTask.name, foundTask.description, wrapTaskWithNode);
    });
}
exports.interceptAndWrapTasksWithNode = interceptAndWrapTasksWithNode;
async function wrapTaskWithNode(taskArgs, env, runSuper) {
    if (env.network.zksync !== true || env.network.name !== plugins_1.HARDHAT_NETWORK_NAME) {
        return await runSuper(taskArgs);
    }
    const zkSyncGlobal = global;
    const { commandArgs, server, port } = await (0, utils_1.startServer)(env.config.zksyncAnvil.version, env.config.zksyncAnvil.binaryPath, false, { quiet: true });
    try {
        await server.listen(commandArgs, false);
        await (0, utils_1.waitForNodeToBeReady)(port);
        const oldNetwork = env.network;
        await (0, utils_1.configureNetwork)(env.config, env.network, port);
        env.injectToGlobal();
        zkSyncGlobal._zkSyncNodeNetwork = env.network;
        const result = await runSuper(taskArgs);
        env.network = oldNetwork;
        delete zkSyncGlobal._zkSyncNodeNetwork;
        env.injectToGlobal();
        return result;
    }
    finally {
        await server.stop();
    }
}
//# sourceMappingURL=global-interceptor.js.map