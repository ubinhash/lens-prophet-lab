"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startServer = exports.configureNetwork = exports.getNetworkConfig = exports.adjustTaskArgsForPort = exports.getAvailablePort = exports.waitForNodeToBeReady = exports.isPortAvailable = exports.download = exports.ensureDirectory = exports.getNodeUrl = exports.resolveTag = exports.getAllTags = exports.getLatestRelease = exports.getRPCServerBinariesDir = exports.getPlatform = exports.constructCommandArgs = void 0;
const path_1 = __importDefault(require("path"));
const axios_1 = __importDefault(require("axios"));
const util_1 = __importDefault(require("util"));
const fs_1 = __importDefault(require("fs"));
const net_1 = __importDefault(require("net"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const child_process_1 = require("child_process");
const global_dir_1 = require("hardhat/internal/util/global-dir");
const construction_1 = require("hardhat/internal/core/providers/construction");
const semver_1 = __importDefault(require("semver"));
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const downloader_1 = require("./downloader");
const server_1 = require("./server");
// Generates command arguments for running the anvil-zksync binary
function constructCommandArgs(args) {
    const commandArgs = [];
    if (args.port) {
        commandArgs.push(`--port=${args.port}`);
    }
    if (args.log) {
        if (!constants_1.ALLOWED_LOG_VALUES.includes(args.log)) {
            throw new errors_1.ZkSyncNodePluginError(`Invalid log value: ${args.log}`);
        }
        commandArgs.push(`--log=${args.log}`);
    }
    if (args.logFilePath) {
        commandArgs.push(`--log-file-path=${args.logFilePath}`);
    }
    if (args.cache) {
        if (!constants_1.ALLOWED_CACHE_VALUES.includes(args.cache)) {
            throw new errors_1.ZkSyncNodePluginError(`Invalid cache value: ${args.cache}`);
        }
        commandArgs.push(`--cache=${args.cache}`);
    }
    if (args.cacheDir) {
        commandArgs.push(`--cache-dir=${args.cacheDir}`);
    }
    if (args.resetCache) {
        commandArgs.push(`--reset-cache=${args.resetCache}`);
    }
    if (args.overrideBytecodesDir) {
        commandArgs.push(`--override-bytecodes-dir=${args.overrideBytecodesDir}`);
    }
    if (args.showStorageLogs) {
        if (!constants_1.ALLOWED_SHOW_STORAGE_LOGS_VALUES.includes(args.showStorageLogs)) {
            throw new errors_1.ZkSyncNodePluginError(`Invalid showStorageLogs value: ${args.showStorageLogs}`);
        }
        commandArgs.push(`--show-storage-logs=${args.showStorageLogs}`);
    }
    if (args.showVmDetails) {
        if (!constants_1.ALLOWED_SHOW_VM_DETAILS_VALUES.includes(args.showVmDetails)) {
            throw new errors_1.ZkSyncNodePluginError(`Invalid showVmDetails value: ${args.showVmDetails}`);
        }
        commandArgs.push(`--show-vm-details=${args.showVmDetails}`);
    }
    if (args.showGasDetails) {
        if (!constants_1.ALLOWED_SHOW_GAS_DETAILS_VALUES.includes(args.showGasDetails)) {
            throw new errors_1.ZkSyncNodePluginError(`Invalid showGasDetails value: ${args.showGasDetails}`);
        }
        commandArgs.push(`--show-gas-details=${args.showGasDetails}`);
    }
    if (args.verbosity) {
        commandArgs.push(`-${args.verbosity}`);
    }
    if (args.externalL1 !== undefined) {
        commandArgs.push(`--external-l1=${args.externalL1}`);
    }
    if (args.spawnL1 !== undefined) {
        commandArgs.push(`--spawn-l1=${args.spawnL1}`);
    }
    if (args.noRequestSizeLimit) {
        commandArgs.push(`--no-request-size-limit`);
    }
    if (args.autoExecuteL1) {
        commandArgs.push(`--auto-execute-l1=true`);
    }
    if (args.noMining) {
        commandArgs.push(`--no-mining`);
    }
    if (args.blockTime) {
        commandArgs.push(`--block-time=${args.blockTime}`);
    }
    if (args.state) {
        commandArgs.push(`--state=${args.state}`);
    }
    if (args.timestamp) {
        commandArgs.push(`--timestamp=${args.timestamp}`);
    }
    if (args.accounts) {
        commandArgs.push(`--accounts=${args.accounts}`);
    }
    if (args.balance) {
        commandArgs.push(`--balance=${args.balance}`);
    }
    if (args.showNodeConfig) {
        commandArgs.push(`--show-node-config=${args.showNodeConfig}`);
    }
    if (args.quiet) {
        commandArgs.push(`--quiet=${args.quiet}`);
    }
    if (args.devSystemContracts) {
        commandArgs.push(`--dev-system-contracts=${args.devSystemContracts}`);
    }
    if (args.autoImpersonate) {
        commandArgs.push(`--auto-impersonate`);
    }
    if (args.l1GasPrice) {
        commandArgs.push(`--l1-gas-price=${args.l1GasPrice}`);
    }
    if (args.l2GasPrice) {
        commandArgs.push(`--l2-gas-price=${args.l2GasPrice}`);
    }
    if (args.l1PubdataPrice) {
        commandArgs.push(`--l1-pubdata-price=${args.l1PubdataPrice}`);
    }
    if (args.priceScaleFactor) {
        commandArgs.push(`--price-scale-factor=${args.priceScaleFactor}`);
    }
    if (args.limitScaleFactor) {
        commandArgs.push(`--limit-scale-factor=${args.limitScaleFactor}`);
    }
    if (args.baseTokenRatio) {
        commandArgs.push(`--base-token-ratio=${args.baseTokenRatio}`);
    }
    if (args.baseTokenSymbol) {
        commandArgs.push(`--base-token-symbol=${args.baseTokenSymbol}`);
    }
    if (args.anvilZksyncVersion) {
        commandArgs.push(`--version`);
    }
    if (args.anvilZksyncHelp) {
        commandArgs.push(`--help`);
    }
    if (args.configOut) {
        commandArgs.push(`--config-out=${args.configOut}`);
    }
    if (args.healthCheckEndpoint) {
        commandArgs.push(`--health-check-endpoint=${args.healthCheckEndpoint}`);
    }
    if (args.offline) {
        commandArgs.push(`--offline`);
    }
    if (args.noCors) {
        commandArgs.push(`--no-cors`);
    }
    if (args.allowOrigin) {
        commandArgs.push(`--allow-origin=${args.allowOrigin}`);
    }
    if (args.host) {
        commandArgs.push(`--host=${args.host}`);
    }
    if (args.chainId) {
        commandArgs.push(`--chain-id=${args.chainId}`);
    }
    if (args.init) {
        commandArgs.push(`--init=${args.init}`);
    }
    if (args.stateInterval) {
        commandArgs.push(`--state-interval=${args.stateInterval}`);
    }
    if (args.preserveHistoricalStates) {
        commandArgs.push(`--preserve-historical-states`);
    }
    if (args.order) {
        commandArgs.push(`--order=${args.order}`);
    }
    if (args.silent) {
        commandArgs.push(`--silent=${args.silent}`);
    }
    if (args.showNodeConfig) {
        commandArgs.push(`--show-node-config=${args.showNodeConfig}`);
    }
    if (args.protocolVersion) {
        commandArgs.push(`--protocol-version=${args.protocolVersion}`);
    }
    if (args.emulateEvm) {
        commandArgs.push(`--emulate-evm`);
    }
    if (args.enforceBytecodeCompression) {
        commandArgs.push(`--enforce-bytecode-compression=${args.enforceBytecodeCompression}`);
    }
    if (args.systemContractsPath) {
        commandArgs.push(`--system-contracts-path=${args.systemContractsPath}`);
    }
    if (args.forkBlockNumber && args.replayTx) {
        throw new errors_1.ZkSyncNodePluginError(`Cannot specify both --fork-block-number and --replay-tx. Please specify only one of them.`);
    }
    if ((args.replayTx || args.forkBlockNumber) && !args.fork) {
        throw new errors_1.ZkSyncNodePluginError(`Cannot specify --replay-tx or --fork-block-number parameters without --fork param.`);
    }
    if (args.fork) {
        if (args.forkBlockNumber) {
            commandArgs.push('fork', '--fork-url', args.fork, '--fork-at', args.forkBlockNumber.toString());
        }
        else if (args.replayTx) {
            commandArgs.push('replay_tx', '--fork-url', args.fork, args.replayTx);
        }
        else {
            commandArgs.push('fork', '--fork-url', args.fork);
        }
    }
    else {
        commandArgs.push('run');
    }
    return commandArgs;
}
exports.constructCommandArgs = constructCommandArgs;
function getPlatform() {
    return constants_1.PLATFORM_MAP[process.platform] || '';
}
exports.getPlatform = getPlatform;
function getArch() {
    const arch = process.arch === 'x64' ? 'x86_64' : process.arch;
    return process.arch === 'arm64' ? 'aarch64' : arch;
}
// Returns the path to the directory where the anvil-zksync binary is/will be located
async function getRPCServerBinariesDir() {
    const compilersCachePath = await (0, global_dir_1.getCompilersDir)();
    const basePath = path_1.default.dirname(compilersCachePath);
    const rpcServerBinariesPath = path_1.default.join(basePath, 'zksync-memory-node');
    return rpcServerBinariesPath;
}
exports.getRPCServerBinariesDir = getRPCServerBinariesDir;
async function getLatestRelease(owner, repo, userAgent, timeout) {
    const finalUrl = await handleRedirect(`https://github.com/${owner}/${repo}/releases/latest`, userAgent, timeout);
    const match = finalUrl.match(/\/releases\/tag\/v(.*)/);
    if (match) {
        return match[1];
    }
    throw new errors_1.ZkSyncNodePluginError(`Couldn't find the latest release for URL: ${finalUrl}`);
}
exports.getLatestRelease = getLatestRelease;
async function getAllTags(owner, repo, userAgent, timeout) {
    const finalUrl = await handleRedirect(`https://api.github.com/repos/${owner}/${repo}/tags`, userAgent, timeout);
    const { request } = await Promise.resolve().then(() => __importStar(require('undici')));
    const response = await request(finalUrl, {
        headersTimeout: timeout,
        maxRedirections: 0,
        method: 'GET',
        headers: {
            'User-Agent': `${userAgent}`,
        },
    });
    if (response.statusCode === 200) {
        return JSON.parse(await response.body.text()).map((tag) => tag.name.slice(1));
    }
    else {
        throw new errors_1.ZkSyncNodePluginError(`Unexpected response status: ${response.statusCode} for URL: ${finalUrl}`);
    }
}
exports.getAllTags = getAllTags;
async function handleRedirect(url, userAgent, timeout) {
    const { request } = await Promise.resolve().then(() => __importStar(require('undici')));
    let currentUrl = url;
    while (true) {
        const response = await request(currentUrl, {
            headersTimeout: timeout,
            maxRedirections: 0,
            method: 'GET',
            headers: {
                'User-Agent': `${userAgent}`,
            },
        });
        if (response.statusCode >= 300 && response.statusCode < 400) {
            if (response.headers.location && typeof response.headers.location === 'string') {
                currentUrl = response.headers.location;
                continue;
            }
            else {
                throw new errors_1.ZkSyncNodePluginError(`Redirect location not found for URL: ${currentUrl}`);
            }
        }
        else {
            return currentUrl;
        }
    }
}
function resolveTag(tags, latestTag, initialTag) {
    if (initialTag === 'latest') {
        return latestTag;
    }
    const [major, minor, patch] = initialTag.split('.');
    const tag = tags.find((t) => t.startsWith(patch === '*' ? `${major}.${minor}` : initialTag));
    if (!tag) {
        console.warn(`Couldn't find the specified tag: ${initialTag}. Using the latest tag: ${latestTag}`);
        return latestTag;
    }
    return tag;
}
exports.resolveTag = resolveTag;
// Get the asset to download from the latest release of the anvil-zksync binary
async function getNodeUrl(repo, release) {
    const platform = getPlatform();
    // TODO: Add support for Windows
    if (platform === 'windows' || platform === '') {
        throw new errors_1.ZkSyncNodePluginError(`Unsupported platform: ${platform}`);
    }
    return semver_1.default.gt(release, constants_1.ERA_TEST_NODE_BINARY_VERSION)
        ? `${repo}/releases/download/v${release}/anvil-zksync-v${release}-${getArch()}-${platform}.tar.gz`
        : `${repo}/releases/download/v${release}/era_test_node-v${release}-${getArch()}-${platform}.tar.gz`;
}
exports.getNodeUrl = getNodeUrl;
function isTarGzFile(filePath) {
    return path_1.default.extname(filePath) === '.gz' && path_1.default.extname(path_1.default.basename(filePath, '.gz')) === '.tar';
}
function ensureTarGzExtension(filePath) {
    return filePath.endsWith('.tar.gz') ? filePath : `${filePath}.tar.gz`;
}
async function ensureDirectory(filePath, options) {
    await fs_extra_1.default.ensureDir(path_1.default.dirname(filePath), options);
}
exports.ensureDirectory = ensureDirectory;
async function moveFile(sourcePath, destinationPath) {
    await fs_extra_1.default.move(sourcePath, destinationPath, { overwrite: true });
}
function resolveTempFileName(filePath) {
    const { dir, ext, name } = path_1.default.parse(filePath);
    return path_1.default.format({
        dir,
        ext,
        name: `${constants_1.TEMP_FILE_PREFIX}${name}`,
    });
}
// Extracts the contents of a tar.gz archive to a file
async function extractTarGz(tmpFilePath, filePath) {
    const tempExtractionDir = path_1.default.join(path_1.default.dirname(tmpFilePath), `tmp_extract_${Date.now()}`);
    await fs_extra_1.default.ensureDir(tempExtractionDir);
    // Using native tar command for extraction
    await new Promise((resolve, reject) => {
        (0, child_process_1.exec)(`tar -xzf ${tmpFilePath} -C ${tempExtractionDir}`, (error, stdout, _stderr) => {
            if (error) {
                reject(error);
            }
            else {
                resolve(stdout);
            }
        });
    });
    const filesInTempExtractionDir = await fs_extra_1.default.readdir(tempExtractionDir);
    if (filesInTempExtractionDir.length !== 1) {
        throw new Error('Expected a single file inside the tar.gz archive.');
    }
    const extractedFileName = filesInTempExtractionDir[0];
    const extractedFilePath = path_1.default.join(tempExtractionDir, extractedFileName);
    await moveFile(extractedFilePath, filePath.slice(0, -'.tar.gz'.length));
    await fs_extra_1.default.remove(tempExtractionDir);
}
// Downloads a file from a url and saves it to a file path
async function download(url, filePath, userAgent, version, timeoutMillis = 10000, extraHeaders = {}) {
    const { pipeline } = await Promise.resolve().then(() => __importStar(require('stream')));
    const { getGlobalDispatcher, request } = await Promise.resolve().then(() => __importStar(require('undici')));
    const streamPipeline = util_1.default.promisify(pipeline);
    const dispatcher = getGlobalDispatcher();
    // Fetch the url
    const response = await request(url, {
        dispatcher,
        headersTimeout: timeoutMillis,
        maxRedirections: 10,
        method: 'GET',
        headers: {
            ...extraHeaders,
            'User-Agent': `${userAgent} ${version}`,
        },
    });
    if (response.statusCode >= 200 && response.statusCode <= 299) {
        const tmpFilePath = resolveTempFileName(filePath);
        await ensureDirectory(filePath);
        await streamPipeline(response.body, fs_1.default.createWriteStream(tmpFilePath));
        if (isTarGzFile(url)) {
            filePath = ensureTarGzExtension(filePath);
            await extractTarGz(tmpFilePath, filePath);
        }
        else {
            await moveFile(tmpFilePath, filePath);
        }
        await fs_extra_1.default.remove(tmpFilePath);
        return;
    }
    // undici's response bodies must always be consumed to prevent leaks
    const text = await response.body.text();
    // eslint-disable-next-line
    throw new Error(`Failed to download ${url} - ${response.statusCode} received. ${text}`);
}
exports.download = download;
async function isPortAvailableForIP(port, ip) {
    return new Promise((resolve) => {
        const tester = net_1.default
            .createServer()
            .once('error', (err) => resolve(err.code !== 'EADDRINUSE'))
            .once('listening', () => tester.close(() => resolve(true)))
            .listen(port, ip);
    });
}
async function isPortAvailable(port) {
    const availableIPv4 = await isPortAvailableForIP(port, '0.0.0.0');
    const availableIPv6 = await isPortAvailableForIP(port, '::');
    return availableIPv4 && availableIPv6;
}
exports.isPortAvailable = isPortAvailable;
async function waitForNodeToBeReady(port, maxAttempts = 20) {
    const rpcEndpoint = `http://127.0.0.1:${port}`;
    const payload = {
        jsonrpc: '2.0',
        method: 'eth_chainId',
        params: [],
        id: new Date().getTime(),
    };
    let attempts = 0;
    let waitTime = 1000; // Initial wait time in milliseconds
    const backoffFactor = 2;
    const maxWaitTime = 30000; // Maximum wait time (e.g., 30 seconds)
    while (attempts < maxAttempts) {
        try {
            const response = await axios_1.default.post(rpcEndpoint, payload);
            if (response.data && response.data.result) {
                return; // The node responded with a valid chain ID
            }
        }
        catch (e) {
            // console.error(`Attempt ${attempts + 1} failed with error:`, e.message);
            // If it fails, it will just try again
        }
        attempts++;
        // Wait before the next attempt
        await new Promise((r) => setTimeout(r, waitTime));
        // Update the wait time for the next attempt
        waitTime = Math.min(waitTime * backoffFactor, maxWaitTime);
    }
    throw new errors_1.ZkSyncNodePluginError("Server didn't respond after multiple attempts");
}
exports.waitForNodeToBeReady = waitForNodeToBeReady;
async function getAvailablePort(startPort, maxAttempts) {
    let currentPort = startPort;
    for (let i = 0; i < maxAttempts; i++) {
        if (await isPortAvailable(currentPort)) {
            return currentPort;
        }
        currentPort++;
    }
    throw new errors_1.ZkSyncNodePluginError("Couldn't find an available port after several attempts");
}
exports.getAvailablePort = getAvailablePort;
function adjustTaskArgsForPort(taskArgs, currentPort) {
    const portArg = '--port';
    const portArgIndex = taskArgs.indexOf(portArg);
    if (portArgIndex !== -1) {
        if (portArgIndex + 1 < taskArgs.length) {
            taskArgs[portArgIndex + 1] = `${currentPort}`;
        }
        else {
            throw new errors_1.ZkSyncNodePluginError('Invalid task arguments: --port provided without a following port number.');
        }
    }
    else {
        taskArgs.push(portArg, `${currentPort}`);
    }
    return taskArgs;
}
exports.adjustTaskArgsForPort = adjustTaskArgsForPort;
function getNetworkConfig(url) {
    return {
        accounts: constants_1.NETWORK_ACCOUNTS.REMOTE,
        gas: constants_1.NETWORK_GAS.AUTO,
        gasPrice: constants_1.NETWORK_GAS_PRICE.AUTO,
        gasMultiplier: 1,
        httpHeaders: {},
        timeout: 20000,
        url,
        ethNetwork: constants_1.NETWORK_ETH.LOCALHOST,
        chainId: 260,
        zksync: true,
    };
}
exports.getNetworkConfig = getNetworkConfig;
async function configureNetwork(config, network, port) {
    const url = `${constants_1.BASE_URL}:${port}`;
    network.name = constants_1.ZKSYNC_ERA_TEST_NODE_NETWORK_NAME;
    network.config = getNetworkConfig(url);
    config.networks[network.name] = network.config;
    network.provider = await (0, construction_1.createProvider)(config, network.name);
}
exports.configureNetwork = configureNetwork;
const startServer = async (tag, existingBinaryPath, force = false, args) => {
    const platform = getPlatform();
    if (platform === 'windows' || platform === '') {
        throw new errors_1.ZkSyncNodePluginError(`Unsupported platform: ${platform}`);
    }
    const rpcServerBinaryDir = await getRPCServerBinariesDir();
    const downloader = new downloader_1.RPCServerDownloader(rpcServerBinaryDir, tag || 'latest');
    await downloader.downloadIfNeeded(force, existingBinaryPath);
    const binaryPath = await downloader.getBinaryPath();
    const currentPort = await getAvailablePort(constants_1.START_PORT, constants_1.MAX_PORT_ATTEMPTS);
    const commandArgs = constructCommandArgs({ ...args, port: currentPort });
    return {
        commandArgs,
        server: new server_1.JsonRpcServer(binaryPath),
        port: currentPort,
    };
};
exports.startServer = startServer;
//# sourceMappingURL=utils.js.map