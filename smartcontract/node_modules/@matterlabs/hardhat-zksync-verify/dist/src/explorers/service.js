"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerificationService = void 0;
const chalk_1 = __importDefault(require("chalk"));
const utils_1 = require("../utils");
const errors_1 = require("../errors");
const bytecode_1 = require("../solc/bytecode");
const constants_1 = require("../constants");
const plugin_1 = require("../plugin");
const constants_2 = require("./constants");
class VerificationService {
    constructor(hre, verifyUrl, browserUrl) {
        this.hre = hre;
        this.verifyUrl = verifyUrl;
        this.browserUrl = browserUrl;
    }
    static async getCurrentChainConfig(ethereumProvider, customChains, builtinChains) {
        const currentChainId = parseInt(await ethereumProvider.send('eth_chainId'), 16);
        const currentChainConfig = [...[...customChains].reverse(), ...builtinChains].find(({ chainId }) => chainId === currentChainId);
        if (currentChainConfig === undefined) {
            throw new errors_1.ZkSyncVerifyPluginError((0, constants_2.PROVIDED_CHAIN_IS_NOT_SUPPORTED_FOR_VERIFICATION)(currentChainId));
        }
        return currentChainConfig;
    }
    async verify(address, contract, constructorArguments, libraries, noCompile, isWithFullContext = false) {
        const { isAddress } = await Promise.resolve().then(() => __importStar(require('@ethersproject/address')));
        if (!isAddress(address)) {
            throw new errors_1.ZkSyncVerifyPluginError(`${address} is an invalid address.`);
        }
        const deployedBytecodeHex = await (0, utils_1.retrieveContractBytecode)(address, this.hre);
        const deployedBytecode = new bytecode_1.Bytecode(deployedBytecodeHex);
        if (!noCompile) {
            await this.hre.run(constants_1.TASK_COMPILE, { quiet: true });
        }
        const compilerVersions = await this.hre.run(constants_1.TASK_VERIFY_GET_COMPILER_VERSIONS);
        const contractInformation = await this.hre.run(constants_1.TASK_VERIFY_GET_CONTRACT_INFORMATION, {
            contract,
            deployedBytecode,
            matchingCompilerVersions: compilerVersions,
            libraries,
        });
        const optimizationUsed = contractInformation.compilerInput.settings.optimizer.enabled ?? false;
        let deployArgumentsEncoded;
        if (!Array.isArray(constructorArguments)) {
            if (constructorArguments.startsWith('0x')) {
                deployArgumentsEncoded = constructorArguments;
            }
            else {
                throw new errors_1.ZkSyncVerifyPluginError(chalk_1.default.red(constants_1.CONST_ARGS_ARRAY_ERROR));
            }
        }
        else {
            deployArgumentsEncoded = `0x${await (0, utils_1.encodeArguments)(contractInformation.contractOutput.abi, constructorArguments)}`;
        }
        const compilerPossibleVersions = await this.getSupportedCompilerVersions();
        const compilerVersion = contractInformation.solcVersion;
        if (!compilerPossibleVersions.includes(compilerVersion)) {
            throw new errors_1.ZkSyncVerifyPluginError(constants_1.COMPILER_VERSION_NOT_SUPPORTED);
        }
        const request = {
            contractAddress: address,
            sourceCode: (0, plugin_1.getSolidityStandardJsonInput)(this.hre, await (0, plugin_1.getMinimalResolvedFiles)(this.hre, contractInformation.sourceName), contractInformation.compilerInput),
            codeFormat: constants_1.JSON_INPUT_CODE_FORMAT,
            contractName: `${contractInformation.sourceName}:${contractInformation.contractName}`,
            compilerSolcVersion: await this.getSolcVersion(contractInformation),
            compilerZksolcVersion: `v${contractInformation.contractOutput.metadata.zk_version}`,
            constructorArguments: deployArgumentsEncoded,
            optimizationUsed,
        };
        if (isWithFullContext) {
            request.sourceCode.sources = contractInformation.compilerInput.sources;
        }
        const verificationId = await this.getVerificationId(request);
        console.info(chalk_1.default.cyan(`Your verification ID is: ${verificationId}`));
        return {
            contractVerifyDataInfo: {
                contractName: request.contractName,
                contractAddress: request.contractAddress,
            },
            verificationId,
        };
    }
    async getVerificationStatusWithRetry(verificationId, contractVerifyDataInfo, maxRetries = 11, baseRetries = 5, baseDelayInMs = 2000) {
        let retries = 0;
        let response;
        while (true) {
            response = await this.getVerificationStatus(verificationId, contractVerifyDataInfo);
            if (response.isPending()) {
                retries += 1;
                if (retries > maxRetries) {
                    throw new errors_1.ZkSyncVerifyPluginError((0, constants_1.PENDING_CONTRACT_INFORMATION_MESSAGE)(this.browserUrl));
                }
                const delayInMs = (0, utils_1.nextAttemptDelay)(retries, baseDelayInMs, baseRetries);
                await (0, utils_1.delay)(delayInMs);
            }
            else {
                break;
            }
        }
        return response;
    }
}
exports.VerificationService = VerificationService;
//# sourceMappingURL=service.js.map