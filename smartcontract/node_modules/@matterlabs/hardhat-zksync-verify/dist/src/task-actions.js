"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContractInfo = exports.verifyContract = exports.getVerificationSubtasks = exports.getConstructorArguments = exports.getCompilerVersions = exports.verify = exports.resolveArguments = void 0;
const contract_names_1 = require("hardhat/utils/contract-names");
const path_1 = __importDefault(require("path"));
const utils_1 = require("@matterlabs/hardhat-zksync-solc/dist/src/utils");
const constants_1 = require("@matterlabs/hardhat-zksync-solc/dist/src/constants");
const chalk_1 = __importDefault(require("chalk"));
const constants_2 = require("./constants");
const utils_2 = require("./utils");
const errors_1 = require("./errors");
const bytecode_1 = require("./solc/bytecode");
const plugin_1 = require("./plugin");
const config_extractor_1 = require("./config-extractor");
async function resolveArguments(args, hre, _) {
    if (args.address === undefined) {
        throw new errors_1.ZkSyncVerifyPluginError(constants_2.NO_VERIFIABLE_ADDRESS_ERROR);
    }
    const constructorArguments = await hre.run(constants_2.TASK_VERIFY_GET_CONSTRUCTOR_ARGUMENTS, {
        constructorArgsModule: args.constructorArgs,
        constructorArgsParams: args.constructorArgsParams,
    });
    const libraries = await (0, plugin_1.getLibraries)(args.libraries);
    return {
        address: args.address,
        constructorArguments,
        contract: args.contract,
        libraries,
        noCompile: args.noCompile,
    };
}
exports.resolveArguments = resolveArguments;
async function verify(args, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper(args);
    }
    const resolvedAruments = await hre.run(constants_2.TASK_VERIFY_RESOLVE_ARGUMENTS, args);
    const verificationSubtasks = await hre.run(constants_2.TASK_VERIFY_GET_VERIFICATION_SUBTASKS);
    const errors = {};
    for (const { label, subtaskName } of verificationSubtasks) {
        try {
            await hre.run(subtaskName, resolvedAruments);
        }
        catch (error) {
            errors[label] = error;
        }
    }
    const hasErrors = Object.keys(errors).length > 0;
    if (hasErrors) {
        (0, utils_2.printVerificationErrors)(errors);
        process.exit(1);
    }
}
exports.verify = verify;
const extractors = [
    new config_extractor_1.SolcStringUserConfigExtractor(),
    new config_extractor_1.SolcSoloUserConfigExtractor(),
    new config_extractor_1.SolcMultiUserConfigExtractor(),
];
async function getCompilerVersions(_, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper();
    }
    const userSolidityConfig = hre.userConfig.solidity;
    const zkSolcConfig = hre.config.zksolc;
    if (zkSolcConfig.version === constants_1.ZKSOLC_COMPILER_PATH_VERSION) {
        throw new errors_1.ZkSyncVerifyPluginError(constants_2.USING_COMPILER_PATH_ERROR);
    }
    const extractedConfigs = extractors
        .find((extractor) => extractor.suitable(userSolidityConfig))
        ?.extract(userSolidityConfig);
    const latestEraVersion = await (0, utils_1.getLatestEraVersion)();
    const compilerVersions = hre.config.solidity.compilers.map((c) => (0, utils_2.normalizeCompilerVersions)({ compiler: c }, zkSolcConfig, latestEraVersion, extractedConfigs?.compilers ?? []) ?? c.version);
    if (hre.config.solidity.overrides !== undefined) {
        for (const [file, compiler] of Object.entries(hre.config.solidity.overrides)) {
            compilerVersions.push((0, utils_2.normalizeCompilerVersions)({ compiler, file }, zkSolcConfig, latestEraVersion, extractedConfigs?.overides ?? new Map()) ?? compiler.version);
        }
    }
    return compilerVersions;
}
exports.getCompilerVersions = getCompilerVersions;
async function getConstructorArguments(args, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper(args);
    }
    if (typeof args.constructorArgsModule !== 'string') {
        return args.constructorArgsParams;
    }
    const constructorArgsModulePath = path_1.default.resolve(process.cwd(), args.constructorArgsModule);
    try {
        const constructorArguments = await (0, utils_2.extractModule)(constructorArgsModulePath);
        if (!Array.isArray(constructorArguments) && !constructorArguments.startsWith('0x')) {
            throw new errors_1.ZkSyncVerifyPluginError((0, constants_2.ENCODED_ARAGUMENTS_NOT_FOUND_ERROR)(constructorArgsModulePath));
        }
        return constructorArguments;
    }
    catch (error) {
        throw new errors_1.ZkSyncVerifyPluginError((0, constants_2.CONSTRUCTOR_MODULE_IMPORTING_ERROR)(error.message), error);
    }
}
exports.getConstructorArguments = getConstructorArguments;
async function getVerificationSubtasks(_, { config, network }, runSuper) {
    if (!network.zksync) {
        return await runSuper();
    }
    const verificationSubtasks = [];
    let isEtherscanRunned = false;
    if (config.etherscan.apiKey && config.etherscan.enabled) {
        isEtherscanRunned = true;
        verificationSubtasks.push({
            label: 'ZkSyncEtherscan',
            subtaskName: constants_2.TASK_VERIFY_ZKSYNC_ETHERSCAN,
        });
    }
    if (network.config.enableVerifyURL) {
        verificationSubtasks.push({
            label: 'ZkSyncBlockExplorer',
            subtaskName: constants_2.TASK_VERIFY_ZKSYNC_EXPLORER,
        });
        return verificationSubtasks;
    }
    if (isEtherscanRunned) {
        return verificationSubtasks;
    }
    console.warn(chalk_1.default.yellow(`[WARNING] Since Etherscan is disabled or the API key is missing, verification will default to the ZKSync block explorer.`));
    verificationSubtasks.push({
        label: 'ZkSyncBlockExplorer',
        subtaskName: constants_2.TASK_VERIFY_ZKSYNC_EXPLORER,
    });
    return verificationSubtasks;
}
exports.getVerificationSubtasks = getVerificationSubtasks;
async function verifyContract(args, { config, network, run }, runSuper) {
    if (!network.zksync) {
        return await runSuper(args);
    }
    let isEtherscanRunned = false;
    if (config.etherscan.apiKey && config.etherscan.enabled) {
        isEtherscanRunned = true;
        await run(constants_2.TASK_VERIFY_ZKSYNC_ETHERSCAN, args);
    }
    if (network.config.enableVerifyURL) {
        return await run(constants_2.TASK_VERIFY_ZKSYNC_EXPLORER, args);
    }
    if (isEtherscanRunned) {
        return;
    }
    console.warn(chalk_1.default.yellow(`[WARNING] Since Etherscan is disabled or the API key is missing, verification will default to the ZKSync block explorer.`));
    return await run(constants_2.TASK_VERIFY_ZKSYNC_EXPLORER, args);
}
exports.verifyContract = verifyContract;
async function getContractInfo({ contract, deployedBytecode, matchingCompilerVersions, libraries }, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper({ contract, deployedBytecode, matchingCompilerVersions, libraries });
    }
    const artifacts = hre.artifacts;
    let contractInformation;
    if (contract !== undefined) {
        const _ = (0, plugin_1.checkContractName)(artifacts, contract);
        // Process BuildInfo here to check version and throw an error if unexpected version is found.
        const buildInfo = await artifacts.getBuildInfo(contract);
        if (buildInfo === undefined) {
            throw new errors_1.ZkSyncVerifyPluginError((0, constants_2.BUILD_INFO_NOT_FOUND_ERROR)(contract));
        }
        const { sourceName, contractName } = (0, contract_names_1.parseFullyQualifiedName)(contract);
        contractInformation = await (0, bytecode_1.extractMatchingContractInformation)(sourceName, contractName, buildInfo, deployedBytecode);
        if (contractInformation === undefined || contractInformation === null) {
            throw new errors_1.ZkSyncVerifyPluginError(constants_2.NO_MATCHING_CONTRACT);
        }
    }
    else {
        contractInformation = await (0, plugin_1.inferContractArtifacts)(artifacts, matchingCompilerVersions, deployedBytecode);
    }
    return contractInformation;
}
exports.getContractInfo = getContractInfo;
//# sourceMappingURL=task-actions.js.map