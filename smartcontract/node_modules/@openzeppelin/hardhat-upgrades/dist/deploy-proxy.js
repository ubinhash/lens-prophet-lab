"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeDeployProxy = makeDeployProxy;
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const utils_1 = require("./utils");
const utils_2 = require("./defender/utils");
const contract_instance_1 = require("./utils/contract-instance");
const initial_owner_1 = require("./utils/initial-owner");
function makeDeployProxy(hre, defenderModule) {
    return async function deployProxy(ImplFactory, args = [], opts = {}) {
        if (!Array.isArray(args)) {
            opts = args;
            args = [];
        }
        opts = (0, utils_2.enableDefender)(hre, defenderModule, opts);
        const { provider } = hre.network;
        const manifest = await upgrades_core_1.Manifest.forNetwork(provider);
        const { impl, kind } = await (0, utils_1.deployProxyImpl)(hre, ImplFactory, opts);
        const contractInterface = ImplFactory.interface;
        const data = (0, utils_1.getInitializerData)(contractInterface, args, opts.initializer);
        const deployFn = opts.deployFunction || utils_1.deploy;
        if (await manifest.getAdmin()) {
            if (kind === 'uups') {
                (0, upgrades_core_1.logWarning)(`A proxy admin was previously deployed on this network`, [
                    `This is not natively used with the current kind of proxy ('uups').`,
                    `Changes to the admin will have no effect on this new proxy.`,
                ]);
            }
            else if (kind === 'transparent') {
                (0, upgrades_core_1.logWarning)(`A proxy admin was previously deployed on this network`, [
                    `This is not used with new transparent proxy deployments, since new transparent proxies deploy their own admins.`,
                    `Changes to the previous admin will have no effect on this new proxy.`,
                ]);
            }
        }
        const signer = (0, utils_1.getSigner)(ImplFactory.runner);
        let proxyDeployment;
        switch (kind) {
            case 'beacon': {
                throw new upgrades_core_1.BeaconProxyUnsupportedError();
            }
            case 'uups': {
                if (opts.initialOwner !== undefined) {
                    throw new upgrades_core_1.InitialOwnerUnsupportedKindError(kind);
                }
                const ProxyFactory = opts.proxyFactory || (await (0, utils_1.getProxyFactory)(hre, signer));
                proxyDeployment = Object.assign({ kind }, await deployFn(hre, opts, ProxyFactory, impl, data));
                break;
            }
            case 'transparent': {
                const initialOwner = await (0, initial_owner_1.getInitialOwner)(opts, signer);
                if (!opts.unsafeSkipProxyAdminCheck && (await (0, upgrades_core_1.inferProxyAdmin)(provider, initialOwner))) {
                    throw new upgrades_core_1.UpgradesError('`initialOwner` must not be a ProxyAdmin contract.', () => `If the contract at address ${initialOwner} is not a ProxyAdmin contract and you are sure that this contract is able to call functions on an actual ProxyAdmin, skip this check with the \`unsafeSkipProxyAdminCheck\` option.`);
                }
                const TransparentUpgradeableProxyFactory = opts.proxyFactory || (await (0, utils_1.getTransparentUpgradeableProxyFactory)(hre, signer));
                proxyDeployment = Object.assign({ kind }, await deployFn(hre, opts, TransparentUpgradeableProxyFactory, impl, initialOwner, data));
                break;
            }
        }
        await manifest.addProxy(proxyDeployment);
        return (0, contract_instance_1.getContractInstance)(hre, ImplFactory, opts, proxyDeployment);
    };
}
//# sourceMappingURL=deploy-proxy.js.map