"use strict";
/* eslint-disable @typescript-eslint/no-var-requires */
Object.defineProperty(exports, "__esModule", { value: true });
require("@nomicfoundation/hardhat-ethers");
require("./type-extensions");
const config_1 = require("hardhat/config");
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const plugins_1 = require("hardhat/plugins");
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
(0, config_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY, async (args, hre, runSuper) => {
    const { readValidations, ValidationsCacheOutdated, ValidationsCacheNotFound } = await import('./utils/validations.js');
    try {
        await readValidations(hre);
    }
    catch (e) {
        if (e instanceof ValidationsCacheOutdated || e instanceof ValidationsCacheNotFound) {
            args = { ...args, force: true };
        }
        else {
            throw e;
        }
    }
    return runSuper(args);
});
(0, config_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, async (args, hre, runSuper) => {
    const { isNamespaceSupported, validate, solcInputOutputDecoder, makeNamespacedInput, trySanitizeNatSpec } = await import('@openzeppelin/upgrades-core');
    const { writeValidations } = await import('./utils/validations.js');
    // TODO: patch input
    const { output, solcBuild } = await runSuper();
    const { isFullSolcOutput } = await import('./utils/is-full-solc-output.js');
    if (isFullSolcOutput(output)) {
        const decodeSrc = solcInputOutputDecoder(args.input, output);
        let namespacedOutput = undefined;
        if (isNamespaceSupported(args.solcVersion)) {
            let namespacedInput = makeNamespacedInput(args.input, output, args.solcVersion);
            namespacedInput = await trySanitizeNatSpec(namespacedInput, args.solcVersion);
            namespacedOutput = (await runSuper({ ...args, quiet: true, input: namespacedInput })).output;
            const namespacedCompileErrors = getNamespacedCompileErrors(namespacedOutput);
            if (namespacedCompileErrors.length > 0) {
                // If there are compile errors in the namespaced output, show error or warning if needed, then only use the original output
                const msg = `Failed to compile modified contracts for namespaced storage layout validations:\n\n${namespacedCompileErrors.join('\n')}`;
                const preamble = [
                    'Please report this at https://zpl.in/upgrades/report. If possible, include the source code for the contracts mentioned in the errors above.',
                    'This step allows for advanced storage modifications such as tight varible packing when performing upgrades with namespaced storage layouts.',
                ];
                switch (hre.config.namespacedCompileErrors) {
                    case undefined:
                    case 'error': {
                        const { UpgradesError } = await import('@openzeppelin/upgrades-core');
                        const details = [
                            ...preamble,
                            'If you are not using namespaced storage, or if you do not anticipate making advanced modifications to namespaces during upgrades,',
                            "you can set namespacedCompileErrors: 'warn' or namespacedCompileErrors: 'ignore' in your hardhat config to convert this to a warning or to ignore this.",
                        ];
                        throw new UpgradesError(msg, () => details.join('\n'));
                    }
                    case 'warn': {
                        const { logWarning } = await import('@openzeppelin/upgrades-core');
                        const details = [
                            ...preamble,
                            'If you are not using namespaced storage, or if you do not anticipate making advanced modifications to namespaces during upgrades,',
                            "you can set namespacedCompileErrors: 'ignore' in your hardhat config to ignore this.",
                        ];
                        logWarning(msg, details);
                        break;
                    }
                    case 'ignore':
                        break;
                    default:
                        (0, upgrades_core_1.assertUnreachable)(hre.config.namespacedCompileErrors);
                }
                namespacedOutput = undefined;
            }
        }
        const validations = validate(output, decodeSrc, args.solcVersion, args.input, namespacedOutput);
        await writeValidations(hre, validations);
    }
    return { output, solcBuild };
});
function getNamespacedCompileErrors(namespacedOutput) {
    const errors = [];
    if (namespacedOutput.errors !== undefined) {
        for (const error of namespacedOutput.errors) {
            if (error.severity === 'error') {
                errors.push(error.formattedMessage);
            }
        }
    }
    return errors;
}
(0, config_1.extendEnvironment)(hre => {
    hre.upgrades = (0, plugins_1.lazyObject)(() => {
        return makeUpgradesFunctions(hre);
    });
    warnOnHardhatDefender();
    hre.defender = (0, plugins_1.lazyObject)(() => {
        return makeDefenderFunctions(hre);
    });
});
function warnOnHardhatDefender() {
    if (tryRequire('@openzeppelin/hardhat-defender', true)) {
        const { logWarning } = require('@openzeppelin/upgrades-core');
        logWarning('The @openzeppelin/hardhat-defender package is deprecated.', [
            'Uninstall the @openzeppelin/hardhat-defender package.',
            'OpenZeppelin Defender integration is included as part of the Hardhat Upgrades plugin.',
        ]);
    }
}
(0, config_1.extendConfig)((config) => {
    var _a, _b;
    // Accumulate references to all the compiler settings, including overrides
    const settings = [];
    for (const compiler of config.solidity.compilers) {
        compiler.settings ?? (compiler.settings = {});
        settings.push(compiler.settings);
    }
    for (const compilerOverride of Object.values(config.solidity.overrides)) {
        compilerOverride.settings ?? (compilerOverride.settings = {});
        settings.push(compilerOverride.settings);
    }
    // Enable storage layout in all of them
    for (const setting of settings) {
        setting.outputSelection ?? (setting.outputSelection = {});
        (_a = setting.outputSelection)['*'] ?? (_a['*'] = {});
        (_b = setting.outputSelection['*'])['*'] ?? (_b['*'] = []);
        if (!setting.outputSelection['*']['*'].includes('storageLayout')) {
            setting.outputSelection['*']['*'].push('storageLayout');
        }
    }
});
if (tryRequire('@nomicfoundation/hardhat-verify')) {
    (0, config_1.subtask)('verify:etherscan').setAction(async (args, hre, runSuper) => {
        const { verify } = await import('./verify-proxy.js');
        return await verify(args, hre, runSuper);
    });
}
function makeFunctions(hre, defender) {
    const { silenceWarnings, getAdminAddress, getImplementationAddress, getBeaconAddress, getImplementationAddressFromBeacon, } = require('@openzeppelin/upgrades-core');
    const { makeDeployProxy } = require('./deploy-proxy');
    const { makeUpgradeProxy } = require('./upgrade-proxy');
    const { makeValidateImplementation } = require('./validate-implementation');
    const { makeValidateUpgrade } = require('./validate-upgrade');
    const { makeDeployImplementation } = require('./deploy-implementation');
    const { makePrepareUpgrade } = require('./prepare-upgrade');
    const { makeDeployBeacon } = require('./deploy-beacon');
    const { makeDeployBeaconProxy } = require('./deploy-beacon-proxy');
    const { makeUpgradeBeacon } = require('./upgrade-beacon');
    const { makeForceImport } = require('./force-import');
    const { makeChangeProxyAdmin, makeTransferProxyAdminOwnership } = require('./admin');
    return {
        silenceWarnings,
        deployProxy: makeDeployProxy(hre, defender),
        upgradeProxy: makeUpgradeProxy(hre, defender), // block on defender
        validateImplementation: makeValidateImplementation(hre),
        validateUpgrade: makeValidateUpgrade(hre),
        deployImplementation: makeDeployImplementation(hre, defender),
        prepareUpgrade: makePrepareUpgrade(hre, defender),
        deployBeacon: makeDeployBeacon(hre, defender), // block on defender
        deployBeaconProxy: makeDeployBeaconProxy(hre, defender),
        upgradeBeacon: makeUpgradeBeacon(hre, defender), // block on defender
        forceImport: makeForceImport(hre),
        admin: {
            changeProxyAdmin: makeChangeProxyAdmin(hre, defender), // block on defender
            transferProxyAdminOwnership: makeTransferProxyAdminOwnership(hre, defender), // block on defender
        },
        erc1967: {
            getAdminAddress: (proxyAddress) => getAdminAddress(hre.network.provider, proxyAddress),
            getImplementationAddress: (proxyAddress) => getImplementationAddress(hre.network.provider, proxyAddress),
            getBeaconAddress: (proxyAddress) => getBeaconAddress(hre.network.provider, proxyAddress),
        },
        beacon: {
            getImplementationAddress: (beaconAddress) => getImplementationAddressFromBeacon(hre.network.provider, beaconAddress),
        },
    };
}
function makeUpgradesFunctions(hre) {
    return makeFunctions(hre, false);
}
function makeDefenderFunctions(hre) {
    const { makeDeployContract } = require('./deploy-contract');
    const { makeProposeUpgradeWithApproval } = require('./defender/propose-upgrade-with-approval');
    const { makeGetDeployApprovalProcess, makeGetUpgradeApprovalProcess } = require('./defender/get-approval-process');
    const getUpgradeApprovalProcess = makeGetUpgradeApprovalProcess(hre);
    return {
        ...makeFunctions(hre, true),
        deployContract: makeDeployContract(hre, true),
        proposeUpgradeWithApproval: makeProposeUpgradeWithApproval(hre, true),
        getDeployApprovalProcess: makeGetDeployApprovalProcess(hre),
        getUpgradeApprovalProcess: getUpgradeApprovalProcess,
        getDefaultApprovalProcess: getUpgradeApprovalProcess, // deprecated, is an alias for getUpgradeApprovalProcess
    };
}
function tryRequire(id, resolveOnly) {
    try {
        resolveOnly ? require.resolve(id) : require(id);
        return true;
    }
    catch (e) {
        // do nothing
    }
    return false;
}
//# sourceMappingURL=index.js.map